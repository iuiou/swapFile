### 操作系统第五次作业

> 1 叙述缺页中断的处理流程。

* 陷入内核态，保存必要的信息（OS及用户进程状态相关的信息）。
* 查找出来发生页面中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页 面。
* 检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程。
* 查找一个空闲的页框(物理内存中的页面)，如果没有空闲页框则需要通过页面置换算法找到一个需 要换出的页框。
* 如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上。
* 页框“干净”后，操作系统将保持在磁盘上的页面内容复制到该页框中。

* 当磁盘中的页面内容全部装入页框后，向操作系 统发送一个中断。操作系统更新内存中的页表项 ，将虚拟页面映射的页框号更新为写入的页框， 并将页框标记为正常状态。
* 恢复缺页中断发生前的状态，将程序指针重新指向引起缺页中断的指令。
* 程序重新执行引发缺页中断的指令，进行存储访问。

> 假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例如： 0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考：
>
> (1) LRU、FIFO和Clock算法的效果如何？ 
>
> (2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？

（1）

* 上述页面至多有 512 种，如果页框总数大于512，则所有页面都可以装填满，上述三种算法都不会产生缺页中断。
* 如果物理页面的总数小于512，则上述三种算法的效果都不好。
  * 对于 LRU 而言，每次选择最长不用的页面用于替换，在随机页面出现的时候，基本都会将 0 号页面替换掉，而每次随机访问后都会再按照顺序访问页面 0-511，这样0号产生缺页中断，则将1号替换掉，导致1号产生缺页中断，如此这般，之后访问的每一个都会产生缺页中断。
  * 对于 FIFO 算法，其实对于这种循环依次情况来说，最早入队的基本就是最久不用的页面，所以FIFO算法这时候的效率与 LRU 基本相同。
  * CLOCK算法相较于FIFO算法而言，给每个页面一个反悔的机会，只要装填入物理内存之后访问次数大于1，就有一次可以不被替换的机会，但是对于这种情况而言，每次再次访问时基本都是在原页面被替换之后，所以CLOCK算法的优化并没有意义。

（2）

* 观察到页面的出现规律是 0，1，2，3，……，511，之前说到 FIFO 效率很低的原因是每次替换掉最早出现的页面后，不久之后它就会被再次访问，所以不如将最先进队列的替换掉，改成将最新进队列的替换掉，这样每次填满500个页框后，500号页面就会替换掉499，501号页面则会替换掉500……，进行再一次循环时，0-499号页面都可以全部命中，每次访问之多会产生13次缺页中断（包括每次循环后随机生成的一个页面），中断率约为 $\frac{13}{513} \approx 2.5\%$

> 3 假设有10个页面，n个页框。页面的访问顺序为0, 9, 8, 4, 4, 3, 6, 5, 1, 5, 0, 2, 1, 1, 1, 1, 8, 8, 5, 3, 9, 8, 9, 9, 6, 1, 8, 4, 6, 4, 3, 7, 1, 3, 2, 9, 8, 6, 2, 9, 2, 7, 2, 7, 8, 4, 2, 3, 0, 1, 9, 4, 7, 1, 5, 9, 1, 7, 3, 4, 3, 7, 1, 0, 3, 5, 9, 9, 4, 9, 6, 1, 7, 5, 9, 4, 9, 7, 3, 6, 7, 7, 4, 5, 3, 5, 3, 1, 5, 6, 1, 1, 9, 6, 6, 4, 0, 9, 4, 3。当n在[1,10]中取值时，请编写程序实现OPT、LRU、FIFO页面置换算法，并根据页面访问顺序模拟执行，分别计算缺页数量，画出缺页数量随页框数n的变化曲线（3条线）。

编写的 $c++$ 程序如下

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn=100;
int v[maxn];
int cal[maxn];
vector<int> vis;
int n;
bool find(int x){
	for(int i=0;i<vis.size();i++){
		if(vis[i]==x){
			return true;
		}
	}
	return false;
}
int OPT(int num){
	vis.clear();
	int ans=0;
	for(int i=1;i<=n;i++){
		if(find(v[i])) continue;
		else{
			ans++;
			if(vis.size()<num){
				vis.push_back(v[i]);
			}
			else{
				int maxt=0,pos;
				for(int j=0;j<num;j++){
					int yes=0; 
					for(int z=i+1;z<=n;z++){
						if(v[z]==vis[j]){
							yes=1;
							if(z>maxt) 
							{
							    maxt=z,pos=j;
							}
							break;
						}
					}
					if(!yes){
						pos=j;
						break;
					}
				}
				vis[pos]=v[i];
			}
		}
	}
	return ans;
}
int FIFO(int num) {
	vis.clear();
	for(int i=0;i<=30;i++) cal[i]=0;
	int ans=0;
	for(int i=1;i<=n;i++){
		if(find(v[i])){
			continue;
		}
		else{
			ans++;
			if(vis.size()<num){
				vis.push_back(v[i]);
				cal[v[i]]=i;
			}
			else{
				int mn=1e9,pos;
				for(int i=0;i<num;i++){
					if(cal[vis[i]]<mn){
						mn=cal[vis[i]];
						pos=i;
					}
				}
				cal[vis[pos]]=0;
				cal[v[i]]=i;
				vis[pos]=v[i];
			}
		}
	}
	return ans;
}
int LRU(int num){
	vis.clear();
	for(int i=0;i<30;i++) cal[i]=0;
	int ans=0;
	for(int i=1;i<=n;i++){
		if(find(v[i])){
			cal[v[i]]=i;
			continue;
		}
		else{
			ans++;
			if(vis.size()<num){
				vis.push_back(v[i]);
				cal[v[i]]=i;
			}
			else{
				int mn=1e9,pos;
				for(int i=0;i<vis.size();i++){
					if(cal[vis[i]]<mn){
						mn=cal[vis[i]];
						pos=i;
					}
				}
				cal[v[i]]=i;
				vis[pos]=v[i];
			}
		}
	}
	return ans;
}
int main(){
	int x;
	while(~scanf("%d",&x)){
		v[++n]=x;
	}
	for(int i=1;i<=10;i++) printf("%d ",OPT(i));
	puts("");
	for(int i=1;i<=10;i++) printf("%d ",FIFO(i));
	puts("");
	for(int i=1;i<=10;i++) printf("%d ",LRU(i));
	puts("");
} 
```

得到的答案如下表

| 物理页框数 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **OPT**    | 90   | 64   | 48   | 37   | 29   | 22   | 16   | 12   | 11   | 10   |
| **FIFO**   | 90   | 80   | 67   | 59   | 47   | 39   | 30   | 20   | 12   | 10   |
| **LRU**    | 90   | 79   | 71   | 58   | 52   | 42   | 28   | 17   | 13   | 10   |

![image-20210406224758722](C:\Users\iuiou\AppData\Roaming\Typora\typora-user-images\image-20210406224758722.png)

> **4 . 一个32位的虚拟存储系统有两级页表，其逻辑地址中，第22到31位是第一级页表，12位到21位是第二级页表，页内偏移占0到11位。一个进程的地址空间为4GB，如果从0x80000000开始映射4MB大小页表空间，请问第一级页表所占4KB空间的起始地址？并说明理由。（注意B代表字节，一个32位地址占4字节）**

页面占 12 位，页面一共有1MB个，一共占用 4MB的空间，则每一个页表项占用32位，4MB的空间线性映射到4GB的空间，其中有一部分映射到页表所在的页面，页表空间占用了1024页，需要10位去映射，这就是第一级页表的作用。现在从0x80000000的地址开始映射，0x80000000之前存在，0x80000个页面，占用了2MB的空间，之后一个页面用作页目录的话，可以让这一个页表正好映射到整个页表域（4MB），所以第一级页表的起始地址为0x80000000+0x200000=0x80200000。

> **5． 一个32位的虚拟存储系统有两级页表，其逻辑地址中，第22到31位是第一级页表（页目录） 的索引，第12位到21位是第二级页表的索引，页内偏移占第0到11位。每个页表（目录） 项包含20位物理页框号和12位标志位，其中最后1位为页有效位。**
>
> **（1） 请问进程整个的地址空间有多少字节？一页有多少字节？** 
>
> **（2） 如果当前进程的页目录物理基地质、页目录和相应页表内容如图下所示，请 描述访问以下虚拟地址时系统进行地址转换的过程，如可行给出最终访存获 取到的数据。虚拟地址：0x0、0x00803004、0x00402001** 
>
> **（3） 要想访问物理地址 0x326028，需要使用哪个虚拟地址？**

* 32位的虚拟存储系统，一共有4GB的地址空间，页内偏移有12位，则一页有4KB的空间。
* 对于以上虚拟地址，查询数据的过程如下：
  * 0x00402001，写成 2 进制，0b0000 0000 0100 0000 0010 0000 0000 0001，页目录号为 1，查表得页表物理地址为0x1000，及查询页目录本身，二级页表偏移为 0b0000 0000 10，查询页号2，得到物理地址0x5000，页内偏移为1，查得数据为0b0000 0000，即0.
  * 0x00803004，写成 2 进制，0b0000 0000 1000 0000 0011 0000 0000 0100，页目录号为 2，查表得页表物理地址为0x5000，查询物理地址为0x5000的页表，二级页表偏移为3，查询得物理地址为0x20000，页内偏移为4，大端存储查得数据为0，小端查得数据为1
  * 0x0，写成 2 进制，每一位都为0，查询页目录 0 号位置，有效位为0，引发缺页中断。
* 该物理地址，页面内偏移为0x028，页面起始物理地址为 0x326000，在地址为0x20000得页表中有存在该物理地址，则该虚拟地址第二级页表偏移为0b0000 0000 01，0x20000在页目录中号码为3，则虚拟地址为0b0000 0000 1100 0000 0001 0000 0010 1000，即 0x00c01028。