### 面向对象第一单元总结博客

经历过三周的OO学习经历，下面我想分享一下我关于第一单元作业的设计架构和心得体会。

#### PART ONE 架构相关（UML类图）



#### PART TWO 设计与算法相关

> **第一次作业**

第一次作业的总体需要达到的目标是实现简单只含有幂函数的表达式的求导，乍一看这应该是一个很简单的事情，在学习程序设计和数据结构的时候就写过类似的程序。但是题目给出的是一个经过**重定义**的表达式模型，这就对我们需求分析的能力提出了挑战。经过一段时间的分析后，我大概将本次实现本次作业的流程分为三个部分，解析字符串，对表达式求导和输出表达式，在第一单元的以后几次作业中我一直沿用这样的实现流程，由于要求比较直接，所以也不需要太复杂的流程。

对于第一个流程解析字符串，对于本次作业来说难度主要是构造出正则表达式，并将信息提取。一开始由于对于正则表达式不够熟悉，所以和室友讨论了很久才设计成功，最终得到了一个十分冗长的表达式

```java
(?<member>[+-]?([+-]?([+-]?((\\d+)|(x(\\*\\*[+-]?\\d+)?))\\*)*[+-]?((\\d+)|(x(\\*\\*[+-]?\\d+)?))))
```

上述表达式是不包括空格的，目标是捕获出所有的“项”，所以我在进行匹配之前先去除了所有的空格。之后又        通过$\text{java matcher}$ 类中的 $\text {group}$ 方法捕获每个项对应参数，并对乘积形式的项进行合并指数。

对于第二个流程，这里就需要谈谈我的类的设计架构，说实话，由于做第一次作业时候对于面向对象的思想了解不够，对整体架构的设计不是很明智，基本上只是分成了三个类，主类，项类和处理字符串类。项类（Member）支持查询指数和系数，以及输出求导之后的字符串，然后我直接在主类中用一个 $\text {ArrayList<Member>}$ 来表示一个表达式，实现求导。

对于第三个流程，在我目前的架构下，其实就是对容器中的项分别求导然后进行拼接问题。

**关于优化**

第一次的输出优化是可以达到极致的，我注意到了许多可以优化的地方，包括合并同类项，将 $x**2$ 转化为 $x*x$ ，以及将正系数的项放在第一个，这样可以少输出一个符号等，我也确实都做了。这些也基本是一些简单的模拟，非常好实现，但是我还是出了愚蠢的细节bug，导致强侧没有能够全部通过，这也反映了我第一次完成任务后并没有进行充分的测试，这也是让我十分遗憾的。



> **第二次作业**

这次作业应该是三次作业中最完美的一次了，但是也经历了漫长的思考，设计，码代码和测试并优化的过程。

第二次作业的要求中在原先的幂函数求导的要求上另加了对三角函数的求导过程，并附加了括号的嵌套，这就给整个表达式的呈现方式提供了很大的灵活性。好在指导书上给出了目标表达式的形式化表述，从逻辑上固定了表达式的形式，而且不存在不合法的表达式，也就是说一定可以使用正则表达式将式子表示出来，这样一定程度上降低了解析表达式的难度。

对于解析表达式，根据上述的分析。由于表达式形式被严格定义完成，所以可以沿用上述的方式用正则表达式去严格解析，但是，括号的出现给解析带来了很大的难度，因为表达式和项都是递归定义的！经过与室友的一番讨论，我最终确定了如下的解析算法。注意到，任意表达式都能写成：
$$
\sum kx^p*f_1(x)*f_2(x)*f_3(x)…*f_m(x)*(…)_1*(…)_2…(…)_n \\
 k,p,m,n \in N
$$
如果我们将所有括号中的表达式都去掉，就会得到如下的结果：
$$
\sum kx^p*f_1()*f_2()*f_3()…*f_m()*()_1*()_2…()_n \\
 k,p,m,n \in N
$$
而这样的形式，就能设计合适的正则表达式去描述，这里我不再展示我当初写出来的正则表达式（~~因为又臭又长~~），在第三次作业我再重点说一种合适的构造正则表达式的方式。按照第一部分所设计出的架构，可以将上述连续乘积形式的每一部分对应到一个固定的因子类，分别进行处理，然后整体得到一个项类，最后将项类组成一个表达式类。这样这样一个表达式就处理成我们想要的样子了。

但是括号里的东西就不要了嘛？当然不是，可以发现，括号里的东西也是一个表达式啊，所以可以重复上述操作就好了啊，编程中什么样的结构形式支持这种反复调用自己的需求呢，当然是递归，怎么递归？对表达式预处理啊，每次都将第一层括号拆开，将括号中的表达式都存在一个数组中，同时删去这一部分。上述过程不就是我们非常熟悉的括号匹配问题嘛？实现它的方法在数据结构课程中就已经教授了，这里不再赘述。每次先递归处理括号内的表达式再处理当前表达式，这就是一个递归的过程。那么递归的终点是什么？就像前面介绍架构说的，循环嵌套的模式，不会达不到重点，在本次作业的终点就是表达式 $x$ ，且如果实现形式没有问题，是一定可以达到这个终点的。

到此为止，我们基本就可以将表达式从字符串形式转化成我们想要的形式了。之后再调用表达式类的求导的方法便可以得到答案了。

再谈谈求导的实现思路，首先有这样的一个公式
$$
(\prod f_1(x)*f_2(x)…f_n(x))^{'} =(f_1(x))^{'}*f_2(x)…f_n(x)+(f_2(x))^{'}*f_1(x)…f_n(x)+(f_n(x))^{'}*f_1(x)…f_{n-1}(x)
$$
也就是说对于乘积的导函数，可以分别对每一项求导，其它不变。对于表达式求导，可以分别求导然后将结果加起来。

既然都设计了这样的循环嵌套的结构，~~不如把第三次的一部分也写了~~，抱着这样的想法，我也实现了嵌套函数的求导，其实也就是 $sin(f(x))$ 和 $cos(f(x))$ 的求导，其实实现起来很简单，因为
$$
sin(f(x))^{'} = cos(f(x))*f(x)^{'} \\
cos(f(x))^{'} = -sin(f(x))*f(x)^{'}
$$
其实调用一下表示求导，以及将 $sin$ 类换成 $cos$ 类，或者相反就行了……，对于不拆括号的版本和拆括号的版本都很好实现。

**关于优化**

输出优化，合并同类项等，思维难度和实现难度都不大，不多赘述。

前面说过，为了使结果尽可能的短，我实际上实现了两种求导的方式。最初我的想法是，在预处理字符串时候将符号全部拆开来，并合并同类项，最终得到的表达式就不包含任何括号，然后直接进行求导，这种方法得到的结果，由于没有括号的嵌套，有时候会十分的长，而想要进一步优化，只能写合并同类项的方法，实现困难且容易出错。那么怎么做到尽量合并同类项呢，注意到表达式中就存在括号相乘，我为什么一定要拆开呢？于是这就产生了我的第二个架构，不拆括号版本。具体架构上面已经说过，细节实现上与拆括号版本没有太多的区别，只是不再增加表达式相乘的模块，将括号表达式看作一个因子放入项类中。解析表达式和求导方式类似，只是不赘述。

最终我将两个求导方式放入两个包中，取最优结果输出。

**关于DEBUG**

对于第二次作业，在测试过程中，出了一个令我 de 了很时间的 bug ，就是对于不拆括号的版本中，由于我为了使得结果尽可能的精简，做了很多的特判，导致由于反复调用$toString()$ 方法，导致递归层数指数式增涨，最终导致对于某些样例复杂度过高而运行超时。对于同一个情况下只需要记忆化递归后的结果然后做出判断即可，不需要反复递归。 

这次debug的经历也提醒我了，记忆化对搜索这样很容易就复杂度爆炸的算法能起到很大很大的简化，当然类似的算法还有剪枝等，只不过这里并用不着。



> **第三次作业**

本单元最后一次作业，相较于第二次多了一个三角函数中允许嵌套表达式的模式，以及一个检查格式是否正确的功能。

对于第一个功能，其实上次我已经实现了，所以这次作业压力很小，相当于只要按照要求调格式和实现检查格式功能即可。实际上，这次作业写码部分并没有花我很多时间，反倒是因为一些新加的细节 $\text {de}$ 了很多 $\text{bug}$…… ，嵌套的实现前面已说过，不再赘述，这次作业最大的两个问题是格式判断和输出优化。

**关于格式判断**

如何指明错误的表达式？有个很朴素的想法，用正确的正则表达式来捕获它，如果得到的表达式是和原表达式没有差别的，那么就是正确的表达式，否则就是错误的表达式。

所以设计好一个正则表达式很重要。然而第三次作业的表达式形式相当的复杂，不是很容易就能表示出来的形式，那怎么办？注意到，我们有形式化定义！形式化定义其实就是正则表达式！所以按照形式化定义的写法一步步递进即可。

![tu](C:\Users\范泽恒\Desktop\tu.jpg)

所以课程组给我们的指导书还是很良心的……

判断格式的流程如下：

* 先对所有括号进行匹配，如果括号无法匹配，直接抛出异常
* 去除表达式前后的空格，之后判断表达式是否为空，如果为空，直接抛出异常。
* 做括号匹配，同之前的一样，提取括号中的表达式，之后对处理后的串做匹配。这里需要注意一下，这里表达式需要分为三角函数中的表达式和不同的表达式，可以用一个参数 id 来表示，如果是三角函数中的表达式，需要特殊判断它是否是一个因子。
* 如果表达式合法，解析表达式，判断当前表达式中每一对括号的归属，也就是计算 id，然后对从括号中提取的表达式进行递归判断。

中间其实涉及到了很多细节，我就因为一个细节没有注意到（对空串的判断），导致最终错了一个测试点……

**关于优化**

首先是输出优化，题目中规定了，三角函数中只能嵌套因子，因此，在很多地方需要补充添加一些括号。但是为了尽量缩短结果，我选则加了一个方法判断当前 项/表达式是否是一个因子，这样可以少加一个 $()$。

其次是方法优化，其实我沿用了之前的架构，从不拆括号和拆括号的两种情况中选择一个最短情况输出。

####  PART THREE 心得和体会

